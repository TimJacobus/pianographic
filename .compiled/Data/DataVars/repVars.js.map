{"version":3,"sources":["../../../src/Data/DataVars/RepVars.js"],"names":["learnedInYear","year1","year2","repertoire","filter","entry","undefined","includes","daysBetweenDates","data","map","dateConverter","date","split","parseInt","x","Date","dateDiff","first","second","Math","round","averageNumberOfDays","arr","tempArr","i","length","avArr","daysArr","reduce","a","b","push","repertoireObjectCreator","listOfComposers","Set","repObj","composerArr","slice","repPiecesByComposer","obj","returnObj","dataKeys","Object","keys","dateRepObjCreator","index","year","dateObj","dateKeys","repCopy","j","dateRepObjNum","objCopy","assign","objKeys","objValues","key","started2017Finished2018","started2018Finished2018","started2017InProgress","started2018InProgress","daysToLearn2017","daysToLearn2018","averageDaysToLearnRep","repPiecesByComposerObj","numberOfPiecesPerComposer","startedInMonth","finishedInMonth","amountStartedInMonth","amountFinishedInMonth","console","log"],"mappings":"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","file":"RepVars.js","sourcesContent":["import { repertoire } from '../DataTxt/Data';\nimport { timeSpentOn } from './DayVars';\n\n\n//    FUNCTIONS\n\n//  I've opted against adding a third parameter for the dataset you want to use. This is because it only really works to filter the repertoire file anyway; it makes more sense to directly access repertoire in the function.\n//  The learnedInYear function takes two arguments: the starting year and the completion year. It's set up to work only if the input data txt file has the dates at the right indexes.\n//  The second parameter, year 2, is optional. If it's passed as an argument, the first line of code runs. If it isn't passed, the second line of code runs.\n//  The first line returns an array of entries which match both years at the given input. A ternary expression is used to account for the possibility of [5] of each entry being an empty string.\n//  The second line returns an array of entries which were started in a certain year, but were not yet completed at the end of last year.\n\nconst learnedInYear = (year1, year2) => {\n  return year2 ? repertoire.filter(entry => entry[5] !== undefined ? entry[4].includes(year1) && entry[5].includes(year2) : null) \n    : repertoire.filter(entry => entry[4].includes(year1) && !entry[5]);\n};\n\n//  A function which takes data as an argument, converts the dates to allow for JS usage, and calculates the amount of days between these two days.\n//  This function specifically only correctly converts the data it expects. You can easily turn this into a more general appliance if you need.\n\nconst daysBetweenDates = (data) => {  \n  return data.map((entry) => {\n    const dateConverter = (date) => {\n      let split = date.split('-').map(x => parseInt(x));\n      return new Date(split[0], (split[1]-1), (split[2]+1));\n    }\n\n    const dateDiff = (first, second) => {\n      return Math.round((second-first)/(1000*60*60*24))\n    }\n\n    return [entry[0], entry[1], entry[2], entry[3], dateDiff(dateConverter(entry[4]), dateConverter(entry[5]))+1];\n  });\n};\n\n\n//  This function takes an unknown number of arguments. \n//  A for loop iterates through the arguments and creates an array out of each argument. Each array has two entries, [0] holds the total time for all pieces, [1] holds the number of pieces.\n//  These arrays get pushed into the tempArr array. Inside the return statement, we sum the total time at [0] and the number of pieces at [1], and then divide the total time by the total number of pieces.\n\nconst averageNumberOfDays = (...arr) => {\n  let tempArr = [];\n  for (let i = 0; i < arr.length; i++) {\n    const avArr = (data) => {\n      let daysArr = data.map(entry => entry[4]);\n      return [\n        daysArr.reduce((a, b) => a + b),\n        daysArr.length\n      ];\n    }\n    tempArr.push(avArr(arr[i]));\n  };\n  return Math.round((tempArr.map(entry => entry[0]).reduce((a, b) => a + b))/tempArr.map(entry => entry[1]).reduce((a, b) => a + b));\n};\n\n//  This function creates an object. Its keys are the composers, and each key has an array as a value. Each entry of this array is another array containing a work that's been learned.\n//  The keys are set to just the last name of the composer. If I ever want access to the full name of a composer, I'll just create a separate object or array.\n\nconst repertoireObjectCreator = () => {\n  const listOfComposers = [...new Set(repertoire.map(entry => entry[0]))];\n  const repObj = {};\n  \n  for (let i = 0; i < listOfComposers.length; i++) {\n    const composerArr = timeSpentOn(repertoire, 0, listOfComposers[i]); \n\n    repObj[listOfComposers[i].split(',')[0]] = \n      composerArr.map(entry => entry.slice(1, 4))\n  };\n  return repObj;\n};\n\n\n//  This function takes the result of repertoireObjectCreator and converts it to an object with keys (composers) and values (number of pieces).\nconst repPiecesByComposer = (obj) => {\n  let returnObj = {}\n  let dataKeys = Object.keys(obj)\n\n  for (let i = 0; i < dataKeys.length; i++) {    \n    returnObj[dataKeys[i]] = obj[dataKeys[i]].length;\n  }\n  return returnObj;\n}\n\n//  This function creates an object with keys (months) and values (an array which stores a arary entries for each piece learned).\n//  repCopy maps each entry. repCopy maps a new array of each piece that's learned. [4] holds the month in which it was started, [5] holds the month in which it was finished, and [6] holds the year \n//  from the date stored at index. This year will be used to check whether the piece was started/finished in the year we passed as an argument.\nconst dateRepObjCreator = (index, year) => {\n  const dateObj = {\n    1: 'January', 2: 'February', 3: 'March', 4: 'April', 5: 'May', 6: 'June', 7: 'July', 8: 'August', 9: 'September', 10: 'October', 11: 'November', 12: 'December'\n  }\n  const dateKeys = Object.keys(dateObj);\n  let returnObj = {};\n\n  const repCopy = [...repertoire].map(entry => entry[5] !== undefined\n    ? [entry[0], entry[1], entry[2], entry[3], parseInt(entry[4].split('-').slice(1, 2)), parseInt(entry[5].split('-').slice(1, 2)), parseInt(entry[index].split('-').slice(0, 1))]\n    : [entry[0], entry[1], entry[2], entry[3], parseInt(entry[4].split('-').slice(1, 2)), null, parseInt(entry[index].split('-').slice(0, 1))]);  \n\n  for (let i = 0; i < dateKeys.length; i++) {\n    for (let j = 0; j < repCopy.length; j++) {\n      if (repCopy[j][index] !== undefined) {\n        // eslint-disable-next-line eqeqeq\n        returnObj[dateObj[i+1]] = repCopy.filter(entry => entry[index] == dateKeys[i] && entry[6] == year).map(entry => [entry[0].split(',')[0], entry[1], entry[2], entry[3]]) \n      }      \n    }\n  }\n  return returnObj;\n}\n\n//  This function converts an object from the function above to an object of key (month) value (number of pieces) pairs.\nconst dateRepObjNum = (obj) => {\n  const objCopy = Object.assign({}, obj);\n  const objKeys = Object.keys(objCopy);\n  const objValues = objKeys.map(key => obj[key]);\n  const returnObj = {};\n\n  for (let i = 0; i < objKeys.length; i++) {\n    returnObj[objKeys[i]] = objValues[i].length\n  } \n  return returnObj;\n}\n\n//    VARIABLES\n\n//  The following four variables each store an array. Each array stores a self-explanatory set of repertoire pieces. All are included and all are included only once.\nexport const started2017Finished2018 = learnedInYear(2017, 2018);\nexport const started2018Finished2018 = learnedInYear(2018, 2018);\nexport const started2017InProgress = learnedInYear(2017);\nexport const started2018InProgress = learnedInYear(2018);\n\n//  These two variables each store an array similar to the arrays above, but it excludes any dates and, at the [4] entry, includes the number of days it took to learn each piece.\n//  Note that this calculation starts only after initially learning the piece. This is important for the eventual display of data. \nexport const daysToLearn2017 = daysBetweenDates(started2017Finished2018);\nexport const daysToLearn2018 = daysBetweenDates(started2018Finished2018);\n\n//  Self explanatory variable, stores the average amount of days it took to learn a piece of repertoire.\nexport const averageDaysToLearnRep = averageNumberOfDays(daysToLearn2017, daysToLearn2018);\n\n//  The obj stores an object with composer keys. Each key has an array as a value, storing all the pieces learned from that composer.\n//  The numberOfPiecesPerComposer variable stores an object with composer keys and the number of pieces learned by that composer.\nexport const repPiecesByComposerObj = repertoireObjectCreator();\nexport const numberOfPiecesPerComposer = repPiecesByComposer(repPiecesByComposerObj)\n\n//  The upper two variables store keysvalue pairs. The keys are months, the values are arrays with all the entries of everything that was started / finished during that month.\n//  The lower two variable store key-value pairs. The keys are months, the values are the number of pieces started or finished during that month.\nexport const startedInMonth = dateRepObjCreator(4, 2018);\nexport const finishedInMonth = dateRepObjCreator(5, 2018);\n\nexport const amountStartedInMonth = dateRepObjNum(startedInMonth);\nexport const amountFinishedInMonth = dateRepObjNum(finishedInMonth);\n\nconsole.log(repPiecesByComposerObj['Koechlin'].length)"]}
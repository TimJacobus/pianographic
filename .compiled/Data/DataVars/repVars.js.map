{"version":3,"sources":["../../../src/Data/DataVars/RepVars.js"],"names":["learnedInYear","year1","year2","repertoire","filter","entry","undefined","includes","daysBetweenDates","data","map","dateConverter","date","split","parseInt","x","Date","dateDiff","first","second","Math","round","averageNumberOfDays","arr","tempArr","i","length","avArr","daysArr","reduce","a","b","push","repertoireObjectCreator","listOfComposers","Set","repObj","composerArr","substring","slice","repPiecesByComposer","obj","returnObj","dataKeys","Object","keys","dateRepObjCreator","index","year","dateObj","dateKeys","repCopy","j","dateRepObjNum","objCopy","assign","objKeys","objValues","key","started2017Finished2018","started2018Finished2018","started2017InProgress","started2018InProgress","daysToLearn2017","daysToLearn2018","averageDaysToLearnRep","repPiecesByComposerObj","numberOfPiecesPerComposer","startedInMonth","finishedInMonth","amountStartedInMonth","amountFinishedInMonth"],"mappings":"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","file":"RepVars.js","sourcesContent":["import { repertoire } from '../DataTxt/Data';\r\nimport { timeSpentOn } from './DayVars';\r\n\r\n\r\n//    FUNCTIONS\r\n\r\n//  I've opted against adding a third parameter for the dataset you want to use. This is because it only really works to filter the repertoire file anyway; it makes more sense to directly access repertoire in the function.\r\n//  The learnedInYear function takes two arguments: the starting year and the completion year. It's set up to work only if the input data txt file has the dates at the right indexes.\r\n//  The second parameter, year 2, is optional. If it's passed as an argument, the first line of code runs. If it isn't passed, the second line of code runs.\r\n//  The first line returns an array of entries which match both years at the given input. A ternary expression is used to account for the possibility of [5] of each entry being an empty string.\r\n//  The second line returns an array of entries which were started in a certain year, but were not yet completed at the end of last year.\r\n\r\nconst learnedInYear = (year1, year2) => {\r\n  return year2 ? repertoire.filter(entry => entry[5] !== undefined ? entry[4].includes(year1) && entry[5].includes(year2) : null) \r\n    : repertoire.filter(entry => entry[4].includes(year1) && !entry[5]);\r\n};\r\n\r\n//  A function which takes data as an argument, converts the dates to allow for JS usage, and calculates the amount of days between these two days.\r\n//  This function specifically only correctly converts the data it expects. You can easily turn this into a more general appliance if you need.\r\n\r\nconst daysBetweenDates = (data) => {  \r\n  return data.map((entry) => {\r\n    const dateConverter = (date) => {\r\n      let split = date.split('-').map(x => parseInt(x));\r\n      return new Date(split[0], (split[1]-1), (split[2]+1));\r\n    }\r\n\r\n    const dateDiff = (first, second) => {\r\n      return Math.round((second-first)/(1000*60*60*24))\r\n    }\r\n\r\n    return [entry[0], entry[1], entry[2], entry[3], dateDiff(dateConverter(entry[4]), dateConverter(entry[5]))+1];\r\n  });\r\n};\r\n\r\n\r\n//  This function takes an unknown number of arguments. \r\n//  A for loop iterates through the arguments and creates an array out of each argument. Each array has two entries, [0] holds the total time for all pieces, [1] holds the number of pieces.\r\n//  These arrays get pushed into the tempArr array. Inside the return statement, we sum the total time at [0] and the number of pieces at [1], and then divide the total time by the total number of pieces.\r\n\r\nconst averageNumberOfDays = (...arr) => {\r\n  let tempArr = [];\r\n  for (let i = 0; i < arr.length; i++) {\r\n    const avArr = (data) => {\r\n      let daysArr = data.map(entry => entry[4]);\r\n      return [\r\n        daysArr.reduce((a, b) => a + b),\r\n        daysArr.length\r\n      ];\r\n    }\r\n    tempArr.push(avArr(arr[i]));\r\n  };\r\n  return Math.round((tempArr.map(entry => entry[0]).reduce((a, b) => a + b))/tempArr.map(entry => entry[1]).reduce((a, b) => a + b));\r\n};\r\n\r\n//  This function creates an object. Its keys are the composers, and each key has an array as a value. Each entry of this array is another array containing a work that's been learned.\r\n//  The keys are set to just the last name of the composer. If I ever want access to the full name of a composer, I'll just create a separate object or array.\r\n//  The .substring(1) method is used to remove the double quotes, looks a bit better.\r\n\r\nconst repertoireObjectCreator = () => {\r\n  const listOfComposers = [...new Set(repertoire.map(entry => entry[0]))];\r\n  const repObj = {};\r\n  \r\n  for (let i = 0; i < listOfComposers.length; i++) {\r\n    const composerArr = timeSpentOn(repertoire, 0, listOfComposers[i]); \r\n\r\n    repObj[listOfComposers[i].split(',')[0].substring(1)] = \r\n      composerArr.map(entry => entry.slice(1, 4))\r\n  };\r\n  return repObj;\r\n};\r\n\r\n\r\n//  This function takes the result of repertoireObjectCreator and converts it to an object with keys (composers) and values (number of pieces).\r\nconst repPiecesByComposer = (obj) => {\r\n  let returnObj = {}\r\n  let dataKeys = Object.keys(obj)\r\n\r\n  for (let i = 0; i < dataKeys.length; i++) {    \r\n    returnObj[dataKeys[i]] = obj[dataKeys[i]].length;\r\n  }\r\n  return returnObj;\r\n}\r\n\r\n//  This function creates an object with keys (months) and values (an array which stores a arary entries for each piece learned).\r\n//  repCopy maps each entry. If it has a value at [5], it targets entry[index] and splits the year from it. If [5] has no value, [4] is directly targeted.\r\n//  Targeting [4] directly is not ideal, but I can't target [index] without it throwing an error, because [5] of the final entry is undefined. I get away with it, because if [5] has no value, there's no reason to ever\r\n//  target another index than [4].\r\nconst dateRepObjCreator = (index, year) => {\r\n  const dateObj = {\r\n    1: 'January', 2: 'February', 3: 'March', 4: 'April', 5: 'May', 6: 'June', 7: 'July', 8: 'August', 9: 'September', 10: 'October', 11: 'November', 12: 'December'\r\n  }\r\n  const dateKeys = Object.keys(dateObj);\r\n  let returnObj = {};\r\n  const repCopy = [...repertoire].map(entry => entry[5] !== undefined && entry[5] !== ''  \r\n    ? [entry[0], entry[1], entry[2], entry[3], parseInt(entry[4].split('-').slice(1, 2)), parseInt(entry[5].split('-').slice(1, 2)), parseInt(entry[index].split('-').slice(0, 1))]\r\n    : [entry[0], entry[1], entry[2], entry[3], parseInt(entry[4].split('-').slice(1, 2)), '', parseInt(entry[4].split('-').slice(0, 1))]);  \r\n\r\n  for (let i = 0; i < dateKeys.length; i++) {\r\n    for (let j = 0; j < repCopy.length; j++) {\r\n      if (repCopy[j][index] !== undefined && repCopy[j][index] !== '') {\r\n        // eslint-disable-next-line eqeqeq\r\n        returnObj[dateObj[i+1]] = repCopy.filter(entry => entry[index] == dateKeys[i] && entry[6] == year).map(entry => [entry[0].split(',')[0].substring(1), entry[1], entry[2], entry[3]]) \r\n      }      \r\n    }\r\n  }\r\n  return returnObj;\r\n}\r\n\r\n//  This function converts an object from the function above to an object of key (month) value (number of pieces) pairs.\r\nconst dateRepObjNum = (obj) => {\r\n  const objCopy = Object.assign({}, obj);\r\n  const objKeys = Object.keys(objCopy);\r\n  const objValues = objKeys.map(key => obj[key]);\r\n  const returnObj = {};\r\n\r\n  for (let i = 0; i < objKeys.length; i++) {\r\n    returnObj[objKeys[i]] = objValues[i].length\r\n  } \r\n  return returnObj;\r\n}\r\n\r\n//    VARIABLES\r\n\r\n//  The following four variables each store an array. Each array stores a self-explanatory set of repertoire pieces. All are included and all are included only once.\r\nexport const started2017Finished2018 = learnedInYear(2017, 2018);\r\nexport const started2018Finished2018 = learnedInYear(2018, 2018);\r\nexport const started2017InProgress = learnedInYear(2017);\r\nexport const started2018InProgress = learnedInYear(2018);\r\n\r\n//  These two variables each store an array similar to the arrays above, but it excludes any dates and, at the [4] entry, includes the number of days it took to learn each piece.\r\n//  Note that this calculation starts only after initially learning the piece. This is important for the eventual display of data. \r\nexport const daysToLearn2017 = daysBetweenDates(started2017Finished2018);\r\nexport const daysToLearn2018 = daysBetweenDates(started2018Finished2018);\r\n\r\n//  Self explanatory variable, stores the average amount of days it took to learn a piece of repertoire.\r\nexport const averageDaysToLearnRep = averageNumberOfDays(daysToLearn2017, daysToLearn2018);\r\n\r\n//  The obj stores an object with composer keys. Each key has an array as a value, storing all the pieces learned from that composer.\r\n//  The numberOfPiecesPerComposer variable stores an object with composer keys and the number of pieces learned by that composer.\r\nexport const repPiecesByComposerObj = repertoireObjectCreator();\r\nexport const numberOfPiecesPerComposer = repPiecesByComposer(repPiecesByComposerObj)\r\n\r\n//  The upper two variables store keysvalue pairs. The keys are months, the values are arrays with all the entries of everything that was started / finished during that month.\r\n//  The lower two variable store key-value pairs. The keys are months, the values are the number of pieces started or finished during that month.\r\nexport const startedInMonth = dateRepObjCreator(4, 2018);\r\nexport const finishedInMonth = dateRepObjCreator(5, 2018);\r\n\r\nexport const amountStartedInMonth = dateRepObjNum(startedInMonth);\r\nexport const amountFinishedInMonth = dateRepObjNum(finishedInMonth);"]}